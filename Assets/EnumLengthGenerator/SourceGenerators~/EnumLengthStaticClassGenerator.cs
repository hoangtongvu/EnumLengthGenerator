using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;

namespace EnumLengthStaticClassGenerator
{
    public readonly record struct EnumInfo(string Name, string Namespace, string BaseType, int MemberCount);

    [Generator]
    public class EnumLengthStaticClassGenerator : IIncrementalGenerator
    {
        private const string DefaultEnumBaseType = "int";

        private static readonly HashSet<string> TargetAttributeNames =
        [
            "GenerateEnumLength",
            "GenerateEnumLengthAttribute",
            "EnumLengthGenerator.GenerateEnumLength",
            "EnumLengthGenerator.GenerateEnumLengthAttribute"
        ];

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var enumProvider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (syntaxNode, _) => IsEnumWithGenerateEnumLengthAttribute(syntaxNode),
                    transform: static (context, _) => GetEnumToGenerate(context));

            // Register the source output
            context.RegisterSourceOutput(enumProvider.Collect(),
                static (spc, source) => Execute(source, spc));

        }

        private static bool IsEnumWithGenerateEnumLengthAttribute(SyntaxNode node)
        {
            if (node is not EnumDeclarationSyntax enumDeclaration)
                return false;

            int attributeListCount = enumDeclaration.AttributeLists.Count;

            for (int i = 0; i < attributeListCount; i++)
            {
                var attributes = enumDeclaration.AttributeLists[i].Attributes;
                int attributeCount = attributes.Count;

                for (int j = 0; j < attributeCount; j++)
                {
                    string name = attributes[j].Name.ToString();
                    if (!TargetAttributeNames.Contains(name)) continue;

                    return true;
                }
            }

            return false;

        }

        private static EnumInfo GetEnumToGenerate(GeneratorSyntaxContext context)
        {
            var enumDeclaration = (EnumDeclarationSyntax)context.Node;

            return new EnumInfo
            {
                Name = enumDeclaration.Identifier.ToString(),
                Namespace = Utilities.GetNamespace(enumDeclaration),
                BaseType = GetEnumBaseType(enumDeclaration) ?? DefaultEnumBaseType,
                MemberCount = enumDeclaration.Members.Count,
            };

        }

        private static string GetEnumBaseType(EnumDeclarationSyntax enumDeclaration)
        {
            // Example: enum MyEnum : byte { ... }
            var baseTypeSyntax = enumDeclaration.BaseList?.Types.FirstOrDefault();
            return baseTypeSyntax?.ToString();
        }

        private static void Execute(
            in ImmutableArray<EnumInfo> enumInfos
            , in SourceProductionContext context)
        {
            if (enumInfos.IsDefaultOrEmpty)
                return;

            // Generate source for each enum
            int count = enumInfos.Length;

            for (int i = 0; i < count; i++)
            {
                var enumInfo = enumInfos[i];
                var source = GenerateEnumLengthClass(enumInfo);
                context.AddSource($"{enumInfo.Name}_Length.g.cs", source);
            }

        }

        private static string GenerateEnumLengthClass(in EnumInfo enumInfo)
        {
            var sb = new StringBuilder();

            // Add file header
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine();

            // Add namespace if present
            if (!string.IsNullOrEmpty(enumInfo.Namespace))
            {
                sb.AppendLine($"namespace {enumInfo.Namespace}");
                sb.AppendLine("{");
            }

            // Generate the static class
            var indent = !string.IsNullOrEmpty(enumInfo.Namespace) ? "    " : "";

            sb.AppendLine($"{indent}public static class {enumInfo.Name}_Length");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    public const {enumInfo.BaseType} Value = {enumInfo.MemberCount};");
            sb.AppendLine($"{indent}}}");

            // Close namespace if present
            if (!string.IsNullOrEmpty(enumInfo.Namespace))
            {
                sb.AppendLine("}");
            }

            return sb.ToString();
        }

    }

}