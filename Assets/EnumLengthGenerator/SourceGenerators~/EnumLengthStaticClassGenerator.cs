using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.IO;

namespace EnumLengthGenerator
{
    [Generator]
    public class EnumLengthStaticClassGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new GenerateEnumLengthAttributeSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            const string LOG_FILE_PATH = "C:\\Users\\Administrator\\Desktop\\SourceGenErrors.txt";

            try
            {
                if (!(context.SyntaxReceiver is GenerateEnumLengthAttributeSyntaxReceiver receiver))
                    return;

                int length = receiver.Syntaxes.Count;
                if (length == 0) return;

                for (int i = 0; i < length; i++)
                {
                    var enumDeclaration = receiver.Syntaxes[i];
                    string enumNamespace = this.GetNamespace(enumDeclaration);
                    string enumName = enumDeclaration.Identifier.ToString();
                    string enumBaseType = this.GetEnumBaseType(enumDeclaration);
                    int enumLength = enumDeclaration.Members.Count;

                    this.GenerateEnumLengthStaticClass(context, enumNamespace, enumName, enumBaseType, enumLength);

                }

            }
            catch (Exception e)
            {
                File.AppendAllText(LOG_FILE_PATH, $"Source generator error:\n{e}\n");
            }

        }

        private void GenerateEnumLengthStaticClass(
            GeneratorExecutionContext context
            , string enumNamespace
            , string enumName
            , string enumBaseType
            , int enumLength)
        {
            string className = $"{enumName}_Length";

            string sourceCode = $@"// <auto-generated />
namespace {enumNamespace}
{{
    public static class {className}
    {{
        public const {enumBaseType} Value = {enumLength};
    }}
}}
";

            context.AddSource($"{className}.g.cs", sourceCode);

        }

        private string GetNamespace(SyntaxNode syntaxNode)
        {
            SyntaxNode parent = syntaxNode.Parent;

            while (parent != null)
            {
                if (parent is NamespaceDeclarationSyntax namespaceDeclaration)
                    return namespaceDeclaration.Name.ToString();

                parent = parent.Parent;

            }

            return null;

        }

        private string GetEnumBaseType(EnumDeclarationSyntax enumDeclaration)
        {
            // Example: enum MyEnum : byte { ... }
            var baseTypeSyntax = enumDeclaration.BaseList?.Types.FirstOrDefault();
            return baseTypeSyntax?.ToString();
        }

    }

}